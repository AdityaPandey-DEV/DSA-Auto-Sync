# üíª GeeksforGeeks Solutions

## Overview

This folder contains solutions to GeeksforGeeks (GFG) interview-focused coding problems. All solutions are implemented in **C++** and **Python**, following industry-standard coding practices for technical interviews.

---

## üìä Statistics

![GeeksforGeeks Solved](https://img.shields.io/badge/Problems%20Solved-64-2F8D46?logo=geeksforgeeks&logoColor=white)

**Current Breakdown:**
- Easy: ~25 problems
- Medium: ~30 problems
- Hard: ~9 problems

_Note: Statistics are auto-updated via scripts. Run `python scripts/count_problems.py` to update._

---

## üìÅ Folder Structure

```
geeksforgeeks/
‚îú‚îÄ‚îÄ arrays/              # Array manipulation problems
‚îú‚îÄ‚îÄ strings/             # String algorithm problems
‚îú‚îÄ‚îÄ trees/               # Tree and BST problems
‚îú‚îÄ‚îÄ graphs/              # Graph algorithm problems
‚îú‚îÄ‚îÄ dynamic-programming/ # DP problems
‚îú‚îÄ‚îÄ searching-sorting/   # Search and sort problems
‚îî‚îÄ‚îÄ ...                  # Other topic categories
```

_Note: Organization by topic is optional. Files can also be organized by problem number or name._

---

## üß≠ Navigation

### By Topic Categories

- **Arrays** - Subarray problems, rotations, manipulations
- **Strings** - Pattern matching, palindrome, anagram problems
- **Trees** - Binary trees, BST, traversals, construction
- **Graphs** - BFS, DFS, shortest paths, MST
- **Dynamic Programming** - Classic DP problems and variations
- **Searching & Sorting** - Binary search, advanced sorting
- **Linked Lists** - Manipulation, reversal, merging
- **Stack & Queue** - Stack/queue applications
- **Heap** - Priority queue problems
- **Hashing** - Hash table applications
- **Mathematical** - Number theory, combinatorics

---

## üìã File Naming Convention

**Format:** `{problem-name-slug}.{ext}` or `{problem-number}.{ext}`

**Examples:**
- `kadanes-algorithm.cpp` / `kadanes-algorithm.py`
- `reverse-linked-list.cpp`
- `subarray-with-given-sum.cpp`
- `gfg-1234.cpp` (using GFG problem ID)

Each solution file contains:
- Problem statement (as comment header)
- Approach explanation
- Algorithm steps
- Time and space complexity
- Solution code with comments

---

## üéØ Problem Categories

GeeksforGeeks problems focus on:

- **Arrays & Hashing** - Two sum, subarray sum, frequency counting
- **Strings** - Palindrome, anagram, pattern matching
- **Linked Lists** - Reversal, cycle detection, merging sorted lists
- **Trees** - Tree traversals, BST operations, tree construction
- **Graphs** - BFS, DFS, shortest paths, topological sort
- **Dynamic Programming** - Classic DP patterns, optimization
- **Greedy Algorithms** - Activity selection, fractional knapsack
- **Backtracking** - N-Queens, Sudoku solver, permutations
- **Stack & Queue** - Valid parentheses, next greater element
- **Heap** - K largest/smallest, merge K sorted arrays
- **Bit Manipulation** - Single number, power of 2, bit operations

---

## üöÄ Usage

### Running Solutions

**C++:**
```bash
g++ -std=c++17 {problem-name}.cpp -o solution
./solution
```

**Python:**
```bash
python {problem-name}.py
```

### Testing
Most GFG problems have sample test cases. Create test files:
```bash
echo "5\n1 2 3 4 5" | ./solution
```

### Syncing Solutions

To sync GeeksforGeeks solutions, run:
```bash
bash scripts/gfg_sync.sh
```

This script automatically commits and pushes new GFG solutions.

---

## üìö Interview Focus

GeeksforGeeks problems are designed for technical interviews:

- **Company-Specific Questions** - Problems asked by top tech companies
- **Topic-Wise Practice** - Organized by DSA topics
- **Difficulty Levels** - Easy, Medium, Hard categorization
- **Time Complexity** - Emphasis on optimal solutions
- **Space Optimization** - In-place algorithms where possible

### Common Interview Topics

1. **Arrays & Strings** (30% of interviews)
2. **Trees & Graphs** (25% of interviews)
3. **Dynamic Programming** (20% of interviews)
4. **Linked Lists** (15% of interviews)
5. **Others** (10% of interviews)

---

## üí° Problem-Solving Approach

1. **Understand the Problem** - Read carefully, identify constraints
2. **Design Algorithm** - Think about approach before coding
3. **Optimize** - Consider time and space complexity
4. **Handle Edge Cases** - Empty arrays, single elements, etc.
5. **Code Cleanly** - Write readable, maintainable code
6. **Test Thoroughly** - Test with various inputs

---

## üìö Related Resources

- [Algorithm Notes](../notes/) - Comprehensive DSA notes and templates
- [LeetCode Solutions](../leetcode/) - Interview-focused problems
- [Codeforces Solutions](../codeforces/) - Competitive programming
- [Main README](../README.md) - Repository overview

---

## üîó External Links

- [GeeksforGeeks Platform](https://www.geeksforgeeks.org/)
- [GFG Practice](https://practice.geeksforgeeks.org/)
- [GFG Company-Wise Problems](https://www.geeksforgeeks.org/company-preparation/)
- [GFG Data Structures](https://www.geeksforgeeks.org/data-structures/)

---

## üìù Notes

- All solutions are verified and accepted on GeeksforGeeks
- Solutions follow clean code principles
- Time and space complexity analysis included
- Solutions optimized for interview scenarios
- Code includes helpful comments for understanding

---

_Last updated: Auto-synced via gfg_sync.sh script_

